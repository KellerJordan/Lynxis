{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mdg:validated-method/validated-method-tests.js","filenameRelative":"/packages/mdg:validated-method/validated-method-tests.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mdg:validated-method/validated-method-tests.js.map","sourceFileName":"/packages/mdg:validated-method/validated-method-tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"validated-method-tests"},"ignored":false,"code":"var plainMethod = new ValidatedMethod({\n  name: 'plainMethod',\n  validate: new SimpleSchema({}).validator(),\n  run: function run() {\n    return 'result';\n  }\n});\n\nvar noArgsMethod = new ValidatedMethod({\n  name: 'noArgsMethod',\n  validate: null,\n  run: function run() {\n    return 'result';\n  }\n});\n\nvar methodWithArgs = new ValidatedMethod({\n  name: 'methodWithArgs',\n  validate: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String }\n  }).validator(),\n  run: function run() {\n    return 'result';\n  }\n});\n\nvar methodThrowsImmediately = new ValidatedMethod({\n  name: 'methodThrowsImmediately',\n  validate: null,\n  run: function run() {\n    throw new Meteor.Error('error');\n  }\n});\n\nvar methodReturnsName = new ValidatedMethod({\n  name: 'methodReturnsName',\n  validate: null,\n  run: function run() {\n    return this.name;\n  }\n});\n\nvar methodWithSchemaMixin = new ValidatedMethod({\n  name: 'methodWithSchemaMixin',\n  mixins: [schemaMixin],\n  schema: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String }\n  }),\n  run: function run() {\n    return 'result';\n  }\n});\n\nvar resultReceived = false;\nvar methodWithApplyOptions = new ValidatedMethod({\n  name: 'methodWithApplyOptions',\n  validate: new SimpleSchema({}).validator(),\n  applyOptions: {\n    onResultReceived: function onResultReceived() {\n      resultReceived = true;\n    }\n  },\n  run: function run() {\n    return 'result';\n  }\n});\n\nfunction schemaMixin(methodOptions) {\n  methodOptions.validate = methodOptions.schema.validator();\n  return methodOptions;\n}\n\ndescribe('mdg:method', function () {\n  it('defines a method that can be called', function (done) {\n    plainMethod.call({}, function (error, result) {\n      assert.equal(result, 'result');\n\n      Meteor.call(plainMethod.name, {}, function (error, result) {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('allows methods that take no arguments', function (done) {\n    noArgsMethod.call(function (error, result) {\n      assert.equal(result, 'result');\n\n      Meteor.call(noArgsMethod.name, function (error, result) {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('checks schema', function (done) {\n    [methodWithArgs, methodWithSchemaMixin].forEach(function (method) {\n      method.call({}, function (error, result) {\n        // 2 invalid fields\n        assert.equal(error.errors.length, 2);\n\n        method.call({\n          int: 5,\n          string: \"what\"\n        }, function (error, result) {\n          // All good!\n          assert.equal(result, 'result');\n\n          done();\n        });\n      });\n    });\n  });\n\n  it('throws error if no callback passed', function (done) {\n    methodThrowsImmediately.call({}, function (err) {\n      // If you pass a callback, you get the error in the callback\n      assert.ok(err);\n\n      // If no callback, the error is thrown\n      assert.throws(function () {\n        methodThrowsImmediately.call({});\n      }, /error/);\n\n      done();\n    });\n  });\n\n  it('throws error if a mixin does not return the options object', function () {\n    assert.throws(function () {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function nonReturningFunction() {}],\n        schema: null,\n        run: function run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: The function 'nonReturningFunction' didn't return the options object/);\n\n    assert.throws(function () {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function (args) {\n          return args;\n        }, function () {}],\n        schema: null,\n        run: function run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: One of the mixins didn't return the options object/);\n  });\n\n  it('has access to the name on this.name', function (done) {\n    var ret = methodReturnsName._execute();\n    assert.equal(ret, 'methodReturnsName');\n\n    methodReturnsName.call({}, function (err, res) {\n      // The Method knows its own name\n      assert.equal(res, 'methodReturnsName');\n\n      done();\n    });\n  });\n\n  it('can accept Meteor.apply options', function (done) {\n    if (Meteor.isServer) {\n      // the only apply option that I can think of to test is client side only\n      return done();\n    }\n\n    resultReceived = false;\n    methodWithApplyOptions.call({}, function (err, res) {\n      // The Method knows its own name\n      assert.equal(resultReceived, true);\n\n      done();\n    });\n  });\n});","ast":null,"map":{"version":3,"sources":["/packages/mdg:validated-method/validated-method-tests.js"],"names":[],"mappings":"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","file":"/packages/mdg:validated-method/validated-method-tests.js.map","sourcesContent":["const plainMethod = new ValidatedMethod({\n  name: 'plainMethod',\n  validate: new SimpleSchema({}).validator(),\n  run() {\n    return 'result';\n  }\n});\n\nconst noArgsMethod = new ValidatedMethod({\n  name: 'noArgsMethod',\n  validate: null,\n  run() {\n    return 'result';\n  }\n});\n\nconst methodWithArgs = new ValidatedMethod({\n  name: 'methodWithArgs',\n  validate: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String },\n  }).validator(),\n  run() {\n    return 'result';\n  }\n});\n\nconst methodThrowsImmediately = new ValidatedMethod({\n  name: 'methodThrowsImmediately',\n  validate: null,\n  run() {\n    throw new Meteor.Error('error');\n  }\n});\n\nconst methodReturnsName = new ValidatedMethod({\n  name: 'methodReturnsName',\n  validate: null,\n  run() {\n    return this.name;\n  }\n});\n\nconst methodWithSchemaMixin = new ValidatedMethod({\n  name: 'methodWithSchemaMixin',\n  mixins: [schemaMixin],\n  schema: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String },\n  }),\n  run() {\n    return 'result';\n  }\n});\n\nlet resultReceived = false;\nconst methodWithApplyOptions = new ValidatedMethod({\n  name: 'methodWithApplyOptions',\n  validate: new SimpleSchema({}).validator(),\n  applyOptions: {\n    onResultReceived: function() {\n      resultReceived = true;\n    }\n  },\n  run() {\n    return 'result';\n  }\n});\n\nfunction schemaMixin(methodOptions) {\n  methodOptions.validate = methodOptions.schema.validator();\n  return methodOptions;\n}\n\ndescribe('mdg:method', () => {\n  it('defines a method that can be called', (done) => {\n    plainMethod.call({}, (error, result) => {\n      assert.equal(result, 'result');\n\n      Meteor.call(plainMethod.name, {}, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('allows methods that take no arguments', (done) => {\n    noArgsMethod.call((error, result) => {\n      assert.equal(result, 'result');\n\n      Meteor.call(noArgsMethod.name, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('checks schema', (done) => {\n    [methodWithArgs, methodWithSchemaMixin].forEach((method) => {\n      method.call({}, (error, result) => {\n        // 2 invalid fields\n        assert.equal(error.errors.length, 2);\n\n        method.call({\n          int: 5,\n          string: \"what\",\n        }, (error, result) => {\n          // All good!\n          assert.equal(result, 'result');\n\n          done();\n        });\n      });\n    });\n  });\n\n  it('throws error if no callback passed', (done) => {\n    methodThrowsImmediately.call({}, (err) => {\n      // If you pass a callback, you get the error in the callback\n      assert.ok(err);\n\n      // If no callback, the error is thrown\n      assert.throws(() => {\n        methodThrowsImmediately.call({});\n      }, /error/);\n\n      done();\n    });\n  });\n\n  it('throws error if a mixin does not return the options object', () => {\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function nonReturningFunction() {}],\n        schema: null,\n        run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: The function 'nonReturningFunction' didn't return the options object/);\n\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function (args) { return args}, function () {}],\n        schema: null,\n        run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: One of the mixins didn't return the options object/);\n  });\n\n  it('has access to the name on this.name', (done) => {\n    const ret = methodReturnsName._execute();\n    assert.equal(ret, 'methodReturnsName');\n\n    methodReturnsName.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(res, 'methodReturnsName');\n\n      done();\n    });\n  });\n\n  it('can accept Meteor.apply options', (done) => {\n    if (Meteor.isServer) {\n      // the only apply option that I can think of to test is client side only\n      return done();\n    }\n\n    resultReceived = false;\n    methodWithApplyOptions.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(resultReceived, true);\n\n      done();\n    });\n  });\n});\n"]},"hash":"13170838d019c77fc3107cf31ab86e4b68d88df4"}
